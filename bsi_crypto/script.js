/*
Authors: Aleksander Bober (s18855) & Maciej Dudzik (s18496)
-------------------------------------------------------------
AES:
AES includes three block ciphers: AES-128, AES-192 and AES-256.

AES-128 uses a 128-bit key length to encrypt and decrypt a block of messages, while AES-192 uses a 192-bit key length and AES-256 a 256-bit key length to encrypt and decrypt messages. Each cipher encrypts and decrypts data in blocks of 128 bits using cryptographic keys of 128, 192 and 256 bits, respectively.

Symmetric, also known as secret key, ciphers use the same key for encrypting and decrypting, so the sender and the receiver must both know -- and use -- the same secret key. The government classifies information in three categories: Confidential, Secret or Top Secret. All key lengths can be used to protect the Confidential and Secret level. Top Secret information requires either 192- or 256-bit key lengths.

There are 10 rounds for 128-bit keys, 12 rounds for 192-bit keys and 14 rounds for 256-bit keys. A round consists of several processing steps that include substitution, transposition and mixing of the input plaintext to transform it into the final output of ciphertext.

The AES encryption algorithm defines numerous transformations that are to be performed on data stored in an array. The first step of the cipher is to put the data into an array -- after which, the cipher transformations are repeated over multiple encryption rounds.

The first transformation in the AES encryption cipher is substitution of data using a substitution table; the second transformation shifts data rows, and the third mixes columns. The last transformation is performed on each column using a different part of the encryption key. Longer keys need more rounds to complete.

--------------------------------------------------------------
RC4:
RC4 was designed in 1987 by Ron Rivest and is one of the most widely software stream cipher and used in popular protocols, such as SSL (protect Internet traffic), WEP (secure wireless networks) and PDF. It’s considered to be fast and simple in terms of software.

RC4 generates a pseudo-random stream of bits (a key-stream). As with any stream cipher, these can be used for encryption by combining it with the plaintext using bit-wise exclusive-or. Decryption is performed the same way (since exclusive-or is a symmetric operation).

To generate the key stream, the cipher makes use of a secret internal state which consists of two parts:
1. A permutation of all 256 possible bytes (denoted "S" below).
2. Two 8-bit index-pointers (denoted "i" and "j").
The permutation is initialized with a variable length key, typically between 40 and 256 bits, using the key-scheduling algorithm (KSA). Then the stream of bits is generated by a pseudo-random generation algorithm.

The lookup stage of RC4. The output byte is selected by looking up the values of S(i) and S(j), adding them together modulo 256, and then looking up the sum in S; S(S(i) + S(j)) is used as a byte of the key-stream, K.

--------------------------------------------------------------
3DES:
The original DES cipher's key size of 56 bits was generally sufficient when that algorithm was designed, but the availability of increasing computational power made brute-force attacks feasible. Triple DES provides a relatively simple method of increasing the key size of DES to protect against such attacks, without the need to design a completely new block cipher algorithm.

A naive approach to increase strength of a block encryption algorithm with short key length (like DES) would be to use two keys (K1,K2) instead of one, and encrypt each block twice: Ek2(Ek1(plaintext)).If the original key length is n bits, one would hope this scheme provides security equivalent to using key 2n bits long. Unfortunately, this approach is vulnerable to meet-in-the-middle attack: given a known plaintext pair (x, y) such that y = Ek2(Ek1(x)), one can revover the key pair (K1, K2) in 2^(n+1) steps, instead of the 2^2n steps one would expect from an ideally secure algorithm with 2n bits of key.
Therefore, Triple DES uses a "key bundle" that comprises three DES keys, K1, K2 and K3, each of 56 bits (excluding parity bits). The encryption algorithm is:
    ciphertext = Ek3(Dk2(Ek1(plaintext))).
That is, DES encrypt with K1, DES decrypt with K2, then DES encrypt with K3.
Decryption is the reverse:
    plaintext = Dk1(Ek2(Dk3(ciphertext))).
That is, decrypt with K3, encrypt with K2, then decrypt with K1.

Each triple encryption encrypts one block of 64 bits of data.

In each case the middle operation is the reverse of the first and last. This improves the strength of the algorithm when using keying option 2 and provides backward compatibility with DES with keying option 3.

--------------------------------------------------------------
RSA:
RSA (Rivest–Shamir–Adleman) is an algorithm used by modern computers to encrypt and decrypt messages. It is an asymmetric cryptographic algorithm. Asymmetric means that there are two different keys. This is also called public key cryptography, because one of the keys can be given to anyone. The other key must be kept private. The algorithm is based on the fact that finding the factors of a large composite number is difficult: when the factors are prime numbers, the problem is called prime factorization. It is also a key pair (public and private key) generator.

RSA involves a public key and private key. The public key can be known to everyone- it is used to encrypt messages. Messages encrypted using the public key can only be decrypted with the private key. The keys for the RSA algorithm are generated the following way:

Choose two different large random prime numbers  p and q

Calculate n=pq
    n is the modulus for the public key and the private keys

Calculate the totient: phi(n)=(p-1)(q-1)

Choose an integer e such that 1 < e < phi(n), and e is co-prime to phi(n) i.e.: e and phi(n) share no factors other than 1; gcd(e,phi(n) = 1.
  e is released as the public key exponent

Compute d to satisfy the congruence relation de = 1 (mod phi(n)) i.e.: de = 1 + x phi(n) for some integer x. (Simply to say : Calculate d = (1+x phi(n))/e to be an integer)
    d is kept as the private key exponent
Notes on the above steps:

Step 1: Numbers can be probabilistically tested for primality.
Step 3: changed in PKCS#1 v2.0 to lambda(n)=lcm(p-1,q-1) instead of phi(n)=(p-1)(q-1).
Step 4: A popular choice for the public exponents is  e = 216 + 1 = 65537. Some applications choose smaller values such as e = 3, 5, or 35 instead. This is done to make encryption and signature verification faster on small devices like smart cards but small public exponents may lead to greater security risks.
Steps 4 and 5 can be performed with the extended Euclidean algorithm.

The public key is made of the modulus n and the public (or encryption) exponent e.
The personal key is made of p,q and the private (or decryption) exponent d which must be kept secret.

--------------------------------------------------------------
Salt:
In cryptography, a salt is random data that is used as an additional input to a one-way function that hashes data, a password or passphrase. Salts are used to safeguard passwords in storage. Historically a password was stored in plaintext on a system, but over time additional safeguards were developed to protect a user's password against being read from the system. A salt is one of those methods.

A new salt is randomly generated for each password. In a typical setting, the salt and the password (or its version after key stretching) are concatenated and processed with a cryptographic hash function, and the output hash value (but not the original password) is stored with the salt in a database. 

--------------------------------------------------------------
SHA-2(256):
Due to the exposed vulnerabilities of SHA-1, cryptographers modified the algorithm to produce SHA-2, which consists of not one but two hash functions known as SHA-256 and SHA-512, using 32- and 64-bit words, respectively. There are additional truncated versions of these hash functions, known as SHA-224, SHA-384, SHA-512/224, and SHA-512/256, which can be used for either part of the algorithm.

SHA-1 and SHA-2 differ in several ways; mainly, SHA-2 produces 224- or 256-sized digests, whereas SHA-1 produces a 160-bit digest; SHA-2 can also have block sizes that contain 1024 bits, or 512 bits, like SHA-1.

Brute force attacks on SHA-2 are not as effective as they are against SHA-1. A brute force search for finding a message that corresponds to a given digest of length LL using brute force would require 2^L2 
L
  evaluations, which makes SHA-2 a lot safer against these kinds of attacks.

--------------------------------------------------------------

source:
    Symetric(AES, RC4, 3DES): https://www.npmjs.com/package/crypto-js
    Asymetric(RSA): https://nodejs.org/api/crypto.html
--------------------------------------------------------------
license:
    MIT
*/
var CryptoJS = require("crypto-js");
var AES = require("crypto-js/aes"); 
var RC4 = require("crypto-js/rc4"); 
var TripleDES = require("crypto-js/tripledes"); 

const crypto = require("crypto")


const readline = require("readline");
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

rl.question("Massage : ", function(message) {
rl.question("Encryption [AES , RC4 , 3DES , RSA] : ", function(enc) {
    
// adding random 12 random generated symbols as salt

var salt = [];
var oryginal_msg = message;

for ( var index = 0 ; index < 12 ; index++){
var y = Math.random();
if (y < 0.5)
  y = 0
else
  y= 1
salt.push(y)
}
message += " "+salt;

if(enc == "AES"){
	var encrypted = CryptoJS.AES.encrypt(message, "Secret Passphrase");

	var decrypted = CryptoJS.AES.decrypt(encrypted, "Secret Passphrase");
}

if(enc == "RC4"){
	var encrypted = CryptoJS.RC4.encrypt(message, "Secret Passphrase");

	var decrypted = CryptoJS.RC4.decrypt(encrypted, "Secret Passphrase");
}

if(enc == "3DES"){
	var encrypted = CryptoJS.TripleDES.encrypt(message, "Secret Passphrase");

	var decrypted = CryptoJS.TripleDES.decrypt(encrypted, "Secret Passphrase");
}

if(enc == "RSA"){

const { publicKey, privateKey } = crypto.generateKeyPairSync("rsa", {
	// The standard secure default length for RSA keys is 2048 bits
	modulusLength: 2048,
})

var encrypted = crypto.publicEncrypt(
	{
		key: publicKey,
		padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,
		oaepHash: "sha256",
	},
	// We convert the data string to a buffer using `Buffer.from`
	Buffer.from(message)
)

var decrypted = crypto.privateDecrypt(
	{
		key: privateKey,
		// In order to decrypt the data, we need to specify the
		// same hashing function and padding scheme that we used to
		// encrypt the data in the previous step
		padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,
		oaepHash: "sha256",
	},
	encrypted
)

}
    //Count execution time
var t0 = new Date().getTime()
for(var i = 0 ; i < 10000 ; i++){
var encrypted_aes_test = CryptoJS.AES.encrypt(message, "Secret Passphrase");
}
var t1 = new Date().getTime()
var aes_time = t1-t0;

var t0 = new Date().getTime()
for(var i = 0 ; i < 10000 ; i++){
var encrypted_rc4_test = CryptoJS.RC4.encrypt(message, "Secret Passphrase");
}
var t1 = new Date().getTime()
var rc4_time = t1-t0;

var t0 = new Date().getTime()
for(var i = 0 ; i < 10000 ; i++){
var encrypted_3des_time = CryptoJS.TripleDES.encrypt(message, "Secret Passphrase");
}
var t1 = new Date().getTime()
var threedes_time = t1-t0;

const { publicKey, privateKey } = crypto.generateKeyPairSync("rsa", {
	// The standard secure default length for RSA keys is 2048 bits
	modulusLength: 2048,
})
var t0 = new Date().getTime()
for(var i = 0 ; i < 10000 ; i++){
var encrypted_rsa_time = crypto.publicEncrypt(
	{
		key: publicKey,
		padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,
		oaepHash: "sha256",
	},
	// We convert the data string to a buffer using `Buffer.from`
	Buffer.from(message)
)
}
var t1 = new Date().getTime()
var rsa_time = t1-t0;



console.log("")

console.log("Message :")
console.log(oryginal_msg)
console.log("")
console.log("Salt :")
console.log(salt)
console.log("")

console.log("Encryption :")
console.log(enc)
console.log("")

console.log("Encrypted :")
console.log(encrypted.toString())
console.log("")

console.log("Decrypted :")
console.log(decrypted.toString())
console.log("")

if(enc != "RSA"){
console.log("Actual Message :")
console.log(decrypted.toString(CryptoJS.enc.Utf8)) 
console.log("")
}

console.log("Time to encrypt msg 10000 times.")
console.log("")
console.log("AES : " + aes_time/10000)
console.log("")
console.log("RC4 : " + rc4_time/10000)
console.log("")
console.log("3DES : " + threedes_time/10000)
console.log("")
console.log("RSA : " + rsa_time/10000)
console.log("")

});  
});

rl.on("close", function() {
    console.log("\nBYE BYE !!!");
    process.exit(0);
});

 

